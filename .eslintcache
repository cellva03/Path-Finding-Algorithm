[{"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/index.js":"1","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/App.js":"2","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/reportWebVitals.js":"3","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/PathVisualizer/PathVisualizer.js":"4","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/Node/Node.js":"5","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/Footer/Footer.js":"6","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/Legend/Legend.js":"7","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/AppNavbar/AppNavbar.js":"8","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/ErrorModal/ErrorModal.js":"9","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/ToolTip/ToolTip.js":"10","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/algorithms/index.js":"11","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/visualizers/index.js":"12","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/maze-algorithms/index.js":"13","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/DarkModeToggle/DarkModeToggle.js":"14","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/ProgressBar/ProgressBar.js":"15","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/algorithms/dfs.js":"16","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/algorithms/dijkstra.js":"17","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/algorithms/bfs.js":"18","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/algorithms/astar.js":"19","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/visualizers/walls.visualizer.js":"20","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/maze-algorithms/recursiveDivision.js":"21","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/maze-algorithms/randomMaze.js":"22","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/visualizers/algorithms.visualizer.js":"23"},{"size":500,"mtime":1675349727975,"results":"24","hashOfConfig":"25"},{"size":279,"mtime":1675349727966,"results":"26","hashOfConfig":"25"},{"size":362,"mtime":1675349727975,"results":"27","hashOfConfig":"25"},{"size":18708,"mtime":1675349727968,"results":"28","hashOfConfig":"25"},{"size":682,"mtime":1675349727968,"results":"29","hashOfConfig":"25"},{"size":269,"mtime":1675349727968,"results":"30","hashOfConfig":"25"},{"size":999,"mtime":1675349727968,"results":"31","hashOfConfig":"25"},{"size":3312,"mtime":1675349727967,"results":"32","hashOfConfig":"25"},{"size":293,"mtime":1675349727968,"results":"33","hashOfConfig":"25"},{"size":1308,"mtime":1675349727969,"results":"34","hashOfConfig":"25"},{"size":1643,"mtime":1675349727967,"results":"35","hashOfConfig":"25"},{"size":480,"mtime":1675349727976,"results":"36","hashOfConfig":"25"},{"size":150,"mtime":1675349727975,"results":"37","hashOfConfig":"25"},{"size":2504,"mtime":1675349727967,"results":"38","hashOfConfig":"25"},{"size":647,"mtime":1675349727969,"results":"39","hashOfConfig":"25"},{"size":1827,"mtime":1675349727967,"results":"40","hashOfConfig":"25"},{"size":1419,"mtime":1675349727967,"results":"41","hashOfConfig":"25"},{"size":1825,"mtime":1675349727967,"results":"42","hashOfConfig":"25"},{"size":1416,"mtime":1675349727967,"results":"43","hashOfConfig":"25"},{"size":888,"mtime":1675349727976,"results":"44","hashOfConfig":"25"},{"size":3343,"mtime":1675349727975,"results":"45","hashOfConfig":"25"},{"size":884,"mtime":1675349727975,"results":"46","hashOfConfig":"25"},{"size":1459,"mtime":1675349727975,"results":"47","hashOfConfig":"25"},{"filePath":"48","messages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"ble27n",{"filePath":"50","messages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56"},{"filePath":"57","messages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"59","messages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"61","messages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"63","messages":"64","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"65"},{"filePath":"66","messages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"68","messages":"69","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"70","messages":"71","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"72","messages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"76","messages":"77","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"78","messages":"79","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"80","messages":"81","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"82","messages":"83","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"84","messages":"85","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"86","messages":"87","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"88","messages":"89","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"90","messages":"91","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"92","messages":"93","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"94","messages":"95","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/index.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/App.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/reportWebVitals.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/PathVisualizer/PathVisualizer.js",["96","97","98"],"import React, { Component } from 'react';\nimport \"./PathVisualizer.scss\";\nimport Node from \"../Node/Node\";\nimport { dijkstra, getNodesInShortestPathOrder, dfs, bfs, astar } from \"../../algorithms\";\nimport { animatePath, animateWalls, setVisualizationState } from \"../../visualizers\";\nimport { recursiveDivisionMaze, randomMaze } from \"../../maze-algorithms\";\nimport AppNavbar from \"../AppNavbar/AppNavbar\";\nimport ErrorModal from '../../components/ErrorModal/ErrorModal';\nimport Footer from \"../Footer/Footer\";\nimport TooltipExampleMulti from '../../components/ToolTip/ToolTip';\nimport Legend from '../Legend/Legend';\n\n// constants - initial coordinates for start and finish nodes \nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\nclass PathVisualizer extends Component {\n    state = {\n        grid: [],\n        mouseIsPressed: false,\n        isPathNotFound: false,\n        visitedNodes: 0,\n        shortestNodes: 0,\n        tooltipOpen: false,\n        isVisualizing: false,\n        mainIsPressed: \"\",\n        startNode_Pos: [START_NODE_ROW, START_NODE_COL],\n        finishNode_Pos: [FINISH_NODE_ROW, FINISH_NODE_COL],\n    }\n\n    // creates the grid when the component is mounted\n    componentDidMount() {\n        const { startNode_Pos, finishNode_Pos } = this.state;\n        let grid = getInitialGrid(startNode_Pos,finishNode_Pos);\n        this.setState({ grid });   \n    }\n\n    // tool tip toggle\n    toggle = () => {\n        this.setState({ tooltipOpen: !this.state.tooltipOpen });\n    }\n\n/*-------------------------------------------------------------mouse events--------------------------------------------------------------- */\n    // handling mouse events to set up walls\n\n    handleMouseDown(row, col) {\n        const { grid, mainIsPressed } = this.state;\n        const node = grid[row][col];\n        if (node.isStart === true && node.isFinish === false) {\n            this.setState({ mainIsPressed: \"start\" });\n            node.isStart = false;\n        }\n        if (node.isFinish === true && node.isStart === false) {\n            this.setState({ mainIsPressed: \"finish\" });\n            node.isFinish = false;\n        }\n        if (mainIsPressed === \"\") {\n            const newGrid = gridWithWallToggled(grid, row, col);\n            this.setState({ grid: newGrid, mouseIsPressed: true });\n        }\n    }\n    \n    handleMouseEnter(row, col) {\n        const { grid, mouseIsPressed, mainIsPressed } = this.state;\n        if (mainIsPressed === \"start\") {\n            const newGrid = gridDynamicNodes(grid, row, col, \"start\");\n            this.setState({ grid: newGrid });\n        }\n        if (mainIsPressed === \"finish\") {\n            const newGrid = gridDynamicNodes(grid, row, col, \"finish\");\n            this.setState({ grid: newGrid });\n        }\n        if (mouseIsPressed && mainIsPressed === \"\") {\n            const newGrid = gridWithWallToggled(grid, row, col);\n            this.setState({ grid: newGrid, mouseIsPressed: true });\n        }\n    }\n\n    handleMouseUp(row,col) {\n        const { mainIsPressed, grid } = this.state;\n        if (mainIsPressed === \"start\") {\n            this.setState({ mainIsPressed: \"\" });\n            const startNode_Pos = [row, col];\n            const newGrid = gridDynamicNodes(grid, row, col, \"start\");\n            this.setState({ mainIsPressed: \"\", startNode_Pos, grid: newGrid });\n        }\n        if (mainIsPressed === \"finish\") {\n            const finishNode_Pos = [row, col];\n            const newGrid = gridDynamicNodes(grid, row, col, \"finish\");\n            this.setState({ mainIsPressed: \"\", finishNode_Pos, grid: newGrid });\n        }\n        this.setState({ mouseIsPressed: false });\n    }\n\n    handleMouseLeave(row, col) {\n        const { grid, mainIsPressed } = this.state;\n        if (mainIsPressed === \"\")\n            return;\n        let newGrid = grid.slice();\n        const node = newGrid[row][col];\n        if (mainIsPressed === \"start\") {\n            const newNode = {\n                ...node,\n                isStart: false,\n                isWall: false\n            }\n            newGrid[row][col] = newNode;\n        }\n        if (mainIsPressed === \"finish\") {\n            const newNode = {\n                ...node,\n                isFinish: false,\n                isWall: false\n            }\n            newGrid[row][col] = newNode;\n        }\n        this.setState({ grid: newGrid });\n    }\n\n/*----------------------------------------------------------algorithm helper functions---------------------------------------------------------*/\n    // dijkstra\n    visualizeDijkstra = () => {\n        if (this.state.isVisualizing)\n            return;\n        const { grid, startNode_Pos, finishNode_Pos } = this.state;\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\n        const startNode = grid[start_X][start_Y];\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\n        const finishNode = grid[finish_X][finish_Y];\n        try {\n            const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n            if (nodesInShortestPathOrder.length === 1)\n                throw \"not possible\";\n            this.setState({\n                shortestNodes: nodesInShortestPathOrder.length,\n                visitedNodes: visitedNodesInOrder.length\n            });\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n        } catch (error) {\n            this.setState({ isPathNotFound: true, isVisualizing: true });\n            setTimeout(() => {\n                this.setState({ isPathNotFound: false, isVisualizing: false });\n            }, 3000);\n        }\n        //this.setState({ isVisualizing: false });\n    }\n\n    // dfs\n    visualizeDFS = () => {\n        if (this.state.isVisualizing)\n            return;\n        const { grid, startNode_Pos, finishNode_Pos } = this.state;\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\n        const startNode = grid[start_X][start_Y];\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\n        const finishNode = grid[finish_X][finish_Y];\n        try {\n            const visitedNodesInOrder = dfs(grid, startNode, finishNode);\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n            this.setState({\n                shortestNodes: nodesInShortestPathOrder.length,\n                visitedNodes: visitedNodesInOrder.length\n            });\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n        } catch (error) {\n            console.log(error)\n            this.setState({ isPathNotFound: true, isVisualizing: true });\n            setTimeout(() => {\n                this.setState({ isPathNotFound: false, isVisualizing: false });\n            }, 3000);\n        }\n    }\n\n    // bfs\n    visualizeBFS = () => {\n        if (this.state.isVisualizing)\n            return;\n        const { grid, startNode_Pos, finishNode_Pos } = this.state;\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\n        const startNode = grid[start_X][start_Y];\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\n        const finishNode = grid[finish_X][finish_Y];\n        try {\n            const visitedNodesInOrder = bfs(grid, startNode, finishNode);\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n            this.setState({\n                shortestNodes: nodesInShortestPathOrder.length,\n                visitedNodes: visitedNodesInOrder.length\n            });\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n        } catch (error) {\n            this.setState({ isPathNotFound: true, isVisualizing: true });\n            setTimeout(() => {\n                this.setState({ isPathNotFound: false, isVisualizing: false });\n            }, 3000);\n        }\n    }\n\n    // astar\n    visualizeAstar = () => {\n        if (this.state.isVisualizing)\n            return;\n        const { grid,startNode_Pos,finishNode_Pos } = this.state;\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\n        const startNode = grid[start_X][start_Y];\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\n        const finishNode = grid[finish_X][finish_Y];\n        try {\n            const visitedNodesInOrder = astar(grid, startNode, finishNode);\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n            if (nodesInShortestPathOrder.length === 1) {\n                throw \"not possible\";\n            }\n            this.setState({\n                shortestNodes: nodesInShortestPathOrder.length,\n                visitedNodes: visitedNodesInOrder.length\n            });\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\n        } catch (error) {\n            this.setState({ isPathNotFound: true, isVisualizing: true });\n            setTimeout(() => {\n                this.setState({ isPathNotFound: false, isVisualizing: false });\n            }, 3000);\n        }\n    }\n\n/*----------------------------------------------------------clear helper functions---------------------------------------------------------*/\n    clearGrid = () => {\n        if (this.state.isVisualizing)\n            return;\n        const { startNode_Pos, finishNode_Pos } = this.state;\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\n        for (let row = 0; row < this.state.grid.length; row++) {\n            for (let col = 0; col < this.state.grid[0].length; col++) {\n                if (!((row === start_X && col === start_Y) || (row === finish_X && col === finish_Y))) {\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\n                }\n            }\n        }\n        const newGrid = getInitialGrid(startNode_Pos,finishNode_Pos);\n        this.setState({ grid: newGrid, visitedNodes: 0, shortestNodes: 0 });\n    }\n\n    clearPath = () => {\n        if (this.state.isVisualizing)\n            return;\n        for (let row = 0; row < this.state.grid.length; row++) {\n            for (let col = 0; col < this.state.grid[0].length; col++) {\n                if ((document.getElementById(`node-${row}-${col}`).className === \"node node-shortest-path\") || document.getElementById(`node-${row}-${col}`).className === \"node node-visited\") {\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\n                }\n            }\n        }\n        const newGrid = getGridWithoutPath(this.state.grid);\n        this.setState({ grid: newGrid, visitedNodes: 0, shortestNodes: 0 });\n    }\n\n/*----------------------------------------------------------maze generations functions---------------------------------------------------------*/\n    generateRecursiveDivisionMaze = () => {\n        if (this.state.isVisualizing)\n            return;\n        this.setState({ isVisualizing: true });\n        const { grid, startNode_Pos,finishNode_Pos } = this.state;\n        const startNode = grid[startNode_Pos[0]][startNode_Pos[1]];\n        const finishNode = grid[finishNode_Pos[0]][finishNode_Pos[1]];\n        const walls = recursiveDivisionMaze(grid, startNode, finishNode);\n        this.animateWalls(walls, grid);\n    }\n\n    generateRandomMaze = () => {\n        if (this.state.isVisualizing)\n            return;\n        this.setState({ isVisualizing: true });\n        const { grid,startNode_Pos,finishNode_Pos } = this.state;\n        const startNode = grid[startNode_Pos[0]][startNode_Pos[1]];\n        const finishNode = grid[finishNode_Pos[0]][finishNode_Pos[1]];\n        const walls = randomMaze(grid, startNode, finishNode);\n        this.animateWalls(walls, grid);\n    }\n\n    animateWalls = (walls, grid) => {\n        for (let i = 0; i <= walls.length; i++) {\n            if (i === walls.length) {\n                setTimeout(() => {\n                    const newGrid = getNewGridWithMaze(this.state.grid, walls);\n                    this.setState({ grid: newGrid, isVisualizing: false });\n                }, 10 * i);\n                return ;\n            }\n            setTimeout(() => {\n                const wall = walls[i];\n                const node = grid[wall[0]][wall[1]];\n                document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-animated-wall\";\n            }, 10 * i);\n        }\n    }\n\n/*------------------------------------------------------------------------------------------------------------------------------*/\n\n    // sets the stae to visualizing, to prevent any other func from executing during the visualization\n    setVisualization = () => {\n        this.setState({\n            isVisualizing: !this.state.isVisualizing\n        });\n    }\n\n    // same as the previous func, but this one to set the state outside of this component, in algorithms visualizing components\n    handleClick = () => {\n        setVisualizationState(this);\n    }\n\n    render() {\n        const { grid, mouseIsPressed, visitedNodes, shortestNodes } = this.state;\n\n        return (\n            <>\n                <TooltipExampleMulti />\n                {this.state.isPathNotFound ? <ErrorModal /> : null }\n                <AppNavbar\n                    handleDijkstra={this.visualizeDijkstra}\n                    handleDFS={this.visualizeDFS}\n                    handleBFS={this.visualizeBFS}\n                    handleAstar={this.visualizeAstar}\n                    handleClearPath={this.clearPath}\n                    handleClearGrid={this.clearGrid}\n                    handleMaze={this.generateRecursiveDivisionMaze}\n                    handleRandomMaze={this.generateRandomMaze}\n                    handleVisualization={this.setVisualization}\n                    visitedNodes={visitedNodes}\n                    shortestNodes={shortestNodes}\n                /><br/>\n\n                <Legend />\n           \n                <div className=\"grid\">\n                    {grid.map((row, rowIdx) => {\n                        return (\n                            <div key={rowIdx} className='node-grid'>\n                                {row.map((node, nodeIdx) => {\n                                    const { row, col, isStart, isFinish, isWall } = node;\n                                    return (\n                                        <Node\n                                            key={nodeIdx}\n                                            row={row}\n                                            col={col}\n                                            isStart={isStart}\n                                            isFinish={isFinish}\n                                            isWall={isWall}\n                                            mouseIsPressed={mouseIsPressed}\n                                            onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                                            onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                                            onMouseUp={(row,col) => this.handleMouseUp(row,col)}\n                                            onMouseLeave={(row, col) => this.handleMouseLeave(row, col)}\n                                        />\n                                    )\n                                })}\n                            </div>\n                        )\n                    })}\n                </div>\n                <Footer />\n            </>\n         );\n    }\n}\n\nexport default PathVisualizer;\n\n/*------------------------------------------------------------helper functions----------------------------------------------------------------*/\n\n// creating the initial grid, calls the createNode() function\n// to initialise the node with initial properties\nconst getInitialGrid = (startNode_Pos,finishNode_Pos) => {\n    let grid = [];\n    // const startNode_Pos = [10, 15];\n    // const finishNode_Pos = [10, 35];\n    for (let row = 0; row < 20; row++) {\n        const currRow = [];\n        for (let col = 0; col < 50; col++) { //  previously I had it as 20*50\n            currRow.push(createNode(row, col, startNode_Pos, finishNode_Pos));\n        }\n        grid.push(currRow);\n    }\n    return grid;\n}\n\n// initialising the node with its initial properties\nconst createNode = (row, col, startNode, finishNode) => {\n    let start_x = startNode[0];\n    let start_y = startNode[1];\n    let finish_x = finishNode[0];\n    let finish_y = finishNode[1];\n\n    return {\n        row,\n        col,\n        isStart: row === start_x && col === start_y,\n        isFinish: row === finish_x && col === finish_y,\n        isWall: false,\n        distance: Infinity,\n        isVisited: false,\n        previousNode: null,\n        distanceToFinishNode: Math.abs(finish_x - row) + Math.abs(finish_y - col)\n    }\n}\n\n// updating the grid, when the walls are tiggered\nconst gridWithWallToggled = (grid, row, col) => {\n    let newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n        ...node,\n        isWall: !node.isWall\n    }\n    newGrid[row][col] = newNode;\n    return newGrid;\n}\n\n\nconst gridDynamicNodes = (grid, row, col, pos) => {\n    console.log(`start node is currently at: row: ${row} col: ${col}`);\n    let newGrid = grid.slice();\n    const node = newGrid[row][col];\n    if (pos === \"start\") {\n        const newNode = {\n            ...node,\n            isStart: true\n        }\n        newGrid[row][col] = newNode;\n    }\n    if (pos === \"finish\") {\n        const newNode = {\n            ...node,\n            isFinish: true\n        }\n        newGrid[row][col] = newNode;\n    }\n    return newGrid;\n}\n\n// updating the grid, resetting the features except for the walls\nconst getGridWithoutPath = (grid) => {\n    let newGrid = grid.slice();\n    for (let row of grid) {\n        for (let node of row) {\n            let newNode = {\n                ...node,\n                distance: Infinity,\n                isVisited: false,\n                previousNode: null,\n                distanceToFinishNode: Math.abs(FINISH_NODE_ROW - node.row) + Math.abs(FINISH_NODE_COL - node.col)\n            };\n            newGrid[node.row][node.col] = newNode;\n        }\n    }\n    return newGrid;\n}\n\nconst getNewGridWithMaze = (grid, walls) => {\n  let newGrid = grid.slice();\n  for (let wall of walls) {\n    let node = grid[wall[0]][wall[1]];\n    let newNode = {\n      ...node,\n      isWall: true,\n    };\n    newGrid[wall[0]][wall[1]] = newNode;\n  }\n  return newGrid;\n};","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/Node/Node.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/Footer/Footer.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/Legend/Legend.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/AppNavbar/AppNavbar.js",["99"],"import React, { useState } from 'react';\nimport \"./AppNavbar.scss\";\nimport {\n  Collapse,\n  Navbar,\n  NavbarToggler,\n  NavbarBrand,\n  Nav,\n  UncontrolledDropdown,\n  DropdownToggle,\n  DropdownMenu,\n  DropdownItem,\n  NavbarText,\n  Button,\n  ButtonGroup\n} from 'reactstrap';\nimport DarkModeToggle from \"../DarkModeToggle/DarkModeToggle\";\nimport ProgressBar from \"../ProgressBar/ProgressBar\";\n\nconst AppNavbar = (props) => {\n  const [isOpen, setIsOpen] = useState(false);\n\n  const toggle = () => setIsOpen(!isOpen);\n\n  return (\n    <div>\n      <Navbar dark expand=\"md\" className='nav-bar'>\n        <img src=\"https://www.anotherlovestory.ie/wp-content/uploads/2017/03/ALGORITHM-LOGO-WHITE-1.png\" alt=\"Logo\" height=\"70px\" width=\"70px\"/>\n        <NavbarBrand href=\"/\" style={{marginLeft:'20px'}}>PathVisualizer</NavbarBrand>\n        <NavbarToggler onClick={toggle} />\n        <Collapse isOpen={isOpen} navbar>\n          <Nav className=\"mr-auto\" navbar>\n            <UncontrolledDropdown nav inNavbar>\n              <DropdownToggle id={\"Tooltip-\" + 5} nav caret style={{color:'white'}} className='drop-down'>\n                Algorithms\n              </DropdownToggle>\n              <DropdownMenu className='drop-menu'>\n                <DropdownItem className='drop-item' onClick={() => { props.handleDijkstra(); props.handleVisualization() }}> \n                  Dijkstra Algorithm\n                </DropdownItem>\n                <DropdownItem className='drop-item' onClick={() => { props.handleDFS(); props.handleVisualization() }}>DFS Algorithm            \n                </DropdownItem>\n                <DropdownItem className='drop-item' onClick={() => { props.handleBFS(); props.handleVisualization() }}>BFS Algorithm\n                </DropdownItem>\n                <DropdownItem className='drop-item' onClick={() => { props.handleAstar(); props.handleVisualization() }}>A* Algorithm\n                </DropdownItem>\n              </DropdownMenu>\n            </UncontrolledDropdown>\n            <UncontrolledDropdown nav inNavbar>\n              <DropdownToggle id={\"Tooltip-\" + 4} nav caret style={{color:'white'}} className='drop-down'>\n                Generate Maze\n              </DropdownToggle>\n              <DropdownMenu className='drop-menu'>\n                <DropdownItem onClick={() => { props.handleMaze(); props.handleVisualization() }} className='drop-item' >Recursive Division\n                </DropdownItem>\n                <DropdownItem onClick={props.handleRandomMaze} className='drop-item' >Random Maze\n                </DropdownItem>\n              </DropdownMenu>\n            </UncontrolledDropdown>\n          </Nav>  \n        </Collapse>\n        <NavbarText id={\"Tooltip-\" + 3} style={{color:'white',margin:'30px'}}>\n          <ProgressBar visitedNodes={props.visitedNodes} shortestNodes={props.shortestNodes}/>\n        </NavbarText>\n        <NavbarText className=\"clear-functions\">\n            <Button id={\"Tooltip-\" + 0} onClick={props.handleClearPath} className='clear-path'>Clear Path</Button>\n            <Button id={\"Tooltip-\" + 1} onClick={props.handleClearGrid} className='clear-grid'>Clear Grid</Button>         \n        </NavbarText>\n        <NavbarText id={\"Tooltip-\" + 2}>\n          <DarkModeToggle />\n        </NavbarText>\n      </Navbar>\n    </div>\n  );\n}\n\nexport default AppNavbar;","/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/ErrorModal/ErrorModal.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/ToolTip/ToolTip.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/algorithms/index.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/visualizers/index.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/maze-algorithms/index.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/DarkModeToggle/DarkModeToggle.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/components/ProgressBar/ProgressBar.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/algorithms/dfs.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/algorithms/dijkstra.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/algorithms/bfs.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/algorithms/astar.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/visualizers/walls.visualizer.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/maze-algorithms/recursiveDivision.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/maze-algorithms/randomMaze.js",[],"/Users/cellva/Desktop/projects/Path-Finding-Algorithm/src/visualizers/algorithms.visualizer.js",[],{"ruleId":"100","severity":1,"message":"101","line":5,"column":23,"nodeType":"102","messageId":"103","endLine":5,"endColumn":35},{"ruleId":"104","severity":1,"message":"105","line":136,"column":17,"nodeType":"106","messageId":"107","endLine":136,"endColumn":38},{"ruleId":"104","severity":1,"message":"105","line":215,"column":17,"nodeType":"106","messageId":"107","endLine":215,"endColumn":38},{"ruleId":"100","severity":1,"message":"108","line":15,"column":3,"nodeType":"102","messageId":"103","endLine":15,"endColumn":14},"no-unused-vars","'animateWalls' is defined but never used.","Identifier","unusedVar","no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","'ButtonGroup' is defined but never used."]